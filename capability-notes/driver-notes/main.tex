\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{tensor}
\usepackage{xspace}
\usepackage[dvipsnames]{xcolor}
\usepackage{iris}
\usepackage{marvosym}
\usepackage{xargs}
\usepackage{listings}

\setlength{\parskip}{0.3em}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\X}[1]{\ensuremath{\mathrm{#1}}}
\newcommand{\V}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\I}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\Sf}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\T}[1]{\texttt{#1}}
\newcommand{\SL}{Separation Logic\xspace}
\newcommand{\pure}[1]{\tensor[^{\ulcorner}]{#1{}}{^{\urcorner}}} %Hacky {} to avoid double superscript
\newcommand{\br}[1]{{\color{BrickRed} #1}}

\newcommand{\FIXME}[1]{{\color{MidnightBlue} FIXME: #1}}

\newcommand{\MMIO}{\Sf{MMIO}\xspace}

\DeclareMathOperator{\initOKo}{init_{OK}}
\DeclareMathOperator{\initOKos}{init^{\X{sem}}_{OK}}
\newcommandx{\initOK}[3][2=r,3=m]{\initOKo(#1,#2,#3)}
\newcommandx{\initOKS}[4][2=r,3=m,4=W]{\initOKos(#1,#2,#3,#4)}
\DeclareMathOperator{\initBCo}{init_{BC}}
\DeclareMathOperator{\initBCos}{init^{\X{sem}}_{BC}}
\newcommandx{\initBC}[2][1=r,2=m]{\initBCo(#1,#2)}
\newcommandx{\initBCS}[3][1=r,2=m,3=W]{\initBCos(#1,#2,#3)}
\DeclareMathOperator{\driverC}{code}
\DeclareMathOperator{\trace}{tr}
\DeclareMathOperator{\lowval}{\Sf{lowval}}
\DeclareMathOperator{\lifto}{\Sf{lift}}
\newcommandx{\trInv}[3][1=P,2=\iota,3]{\operatorname{trInv}^{#2}_{#3}(#1)}
\newcommandx{\trInvNp}[2][1=P,2=\iota]{\trInv[#1][#2][\mathrm{np}]}
\newcommand{\wrap}[1]{\operatorname{wrap}_{\mathrm{#1}}}
\newcommand{\bigast}[2]{\underset{#1}\Sep{\!\!\! #2}\;}
\newcommand{\app}{\mathbin{+\!\!+}}
\newcommand{\nonCap}[1]{\ensuremath{\mathrm{nonCap}(#1)}}

\newenvironment{remark}
{ \bigskip\hrule\vspace{-1.3em}\nobreak
  \paragraph*{Remark:}}
{\vspace*{0.5em}\hrule\medskip}

\newcommand{\rk}[1]{\hyperref[{rk:#1}]{\textbf{[Rk~\ref*{rk:#1}]}}}

\title{Capabilities, MMIO and Robust Safety}
\date{March 10, 2020}

\begin{document}

\maketitle

\section{Memory Mapped I/O: Operational Semantics}

The proposal is to simply represent read and writes to memory-mapped IO
addresses as events in a trace. This says nothing a priori about devices that
might be connected to these IO regions. In particular, without additional
assumptions, reading a byte from a memory-mapped region just returns an
arbitrary value.

If at some point we want to reason under the assumption that we are connected to
a specific device that reacts in a specific way, we can express that as an extra
\SL assertion, that we assume as a pre-condition, and that restricts the set of
different traces that we might observe.

\[
  \begin{array}{lcl}
    \X{EventTy} & := & \X{IOWrite} \; | \; \X{IORead} \\
    \X{Event} & := & \X{EventTy} \times \X{Addr} \times \Z \\
    \X{Trace} & := & \X{list} \; \X{Event} \\
    \X{State} & := & \underbrace{\X{Reg} \times \X{Mem}}_{\text{old state}}
                     \times \X{Trace} \\
  \end{array}
\]

Values of type \X{State} represent the state of a configuration in the
small-step operational semantics. In this setup, we assume the whole semantics
to be parameterized by the range of memory-mapped addresses: \MMIO.

\[
  \begin{array}{lcl}
    \MMIO & := & [\MMIO_{\X{b}}, \MMIO_{\X{e}}) \\
  \end{array}
\]

In the (current) operational semantics without MMIO, the operational semantics
of the \I{Load} instruction is:

\begin{mathpar}
  \inferrule[Load]
  { r[\X{src}] = (p,g,b,e,a) \\ \X{readAllowed}\; p \\ a \in [b,e) }
  { (r, m) \xrightarrow{\I{Load} \; \X{dst} \; \X{src}} (r[\X{dst} := m[a]], m) }
\end{mathpar}

With MMIO, we obtain two rules for \I{Load}:

\begin{mathpar}
  \inferrule[MemLoad]
  { r[\X{src}] = (p,g,b,e,a) \\ \X{readAllowed}\; p \\ a \in [b,e) \\ a \notin \MMIO}
  { (r, m, t) \xrightarrow{\I{Load} \; \X{dst} \; \X{src}}
    (r[\X{dst} := m[a]], m, t) }

  \inferrule[IOLoad]
  { r[\X{src}] = (p,g,b,e,a) \\ \X{readAllowed}\; p \\ a \in [b,e) \\ a \in \MMIO}
  { (r, m, t) \xrightarrow{\I{Load} \; \X{dst} \; \X{src}}
    (r[\X{dst} := x], m, t \app (\X{IORead}, a, x)) }
\end{mathpar}

Notice how in the second rule, we read an arbitrary integer $x$, and record it
in the trace~\rk{opsem:nondet}.
%
The \I{Store} rule would be similar.

\newcommand{\stdin}{\X{in}}


We now have two options when it comes to modeling the memory $m$:
\begin{enumerate}
  \item Include the \MMIO addresses into the map. Notice that, for any address
    in \MMIO, the specific value held by the map $m$ for that address is now
    irrelevant. Indeed, $m$ is never read nor modified for addresses in \MMIO
    (possible exception: see \rk{opsem:pc_in_mmio}). One could choose to enforce
    that a particular dummy value is stored in $m$ for these addresses or to
    leave them unconstrained.
%
  \item Have $m$ model the physical RAM addresses only. This model is closer to
    the conceptual model of state that we wish to implement, since it does not
    require us to talk about the values in the heap that \MMIO locations are
    associated with. It however probably requires threading through the
    operational semantics the invariant that $m$ is disjoint from \MMIO.
\end{enumerate}
%
Both approaches require us to make sure that no points-to chunks $l \mapsto \_$
with $l \in \MMIO$ can be created. In the next section, we assume the second
approach~\rk{opsem:pc_in_mmio}.


\section{\SL Resources}

We added a trace as part of the state, so we wish to also expose it as a \SL
assertion. Recall the current definition of the state interpretation:
\[
  \X{state\_interp} \; (r,m) := \X{gen\_heap\_ctx}\; r \ast \X{gen\_heap\_ctx}\; m
\]


\newcommand{\tracefull}[1]{\ownGhost{\gamma_{\X{T}}}{\authfull{#1}}}
\newcommand{\tracefrag}[1]{\ownGhost{\gamma_{\X{T}}}{\authfrag{#1}}}

The simplest way to account for the trace is to directly expose it in a
monolithic fashion. In that case, the state interpretation additionally holds a
resource for the trace~\rk{resources:mmio_in_m}:

\begin{align*}
    \X{state\_interp} \; (r,m,t) := {} & \X{gen\_heap\_ctx}\; r \ast {}\\
    &\X{gen\_heap\_ctx}\; m \ast \dom(m) \cap \MMIO = \emptyset \ast
    {\color{BrickRed}\tracefull{t}}
\end{align*}

Note that we restrict the usual ``points-to'' assertions to be used only for
non-MMIO addresses. Instead, to assert ownership of the MMIO region, the user
works with assertions of the form $\tracefrag{t'}$. Such an assertion is not
duplicable, and grants full ownership over the trace. In particular, it allows
one to \emph{update} the trace by emitting events, i.e. by performing I/O
operations.

The wp-rules for \I{Load} and \I{Store} need to be updated consequently. For
instance, the rule for a \I{Load} reading the integer $x$ on a MMIO address $a$
now requires $\tracefrag{t}$ in the pre-condition (for some $t$), and provides
$\tracefrag{t \app (\X{IORead}, a, x)}$ in the post-condition.

The corresponding resource algebra is
$\authm(\exm(\X{Trace}))$~\rk{resources:fine_grained_trace}. A few relevant
rules are:

\[
  \begin{array}{l}
    \tracefull{t} \ast \tracefrag{t'} \wand \pure{t = t'} \\
    \tracefrag{t} \ast \tracefrag{t'} \wand \FALSE \\
    \tracefull{t} \ast \tracefrag{t} \vsW \tracefull{t'} \ast \tracefrag{t'} \\
  \end{array}
\]

To simplify notation, let us introduce the following definitions for user-level
ownership over the trace, and preservation of an invariant on the trace,
respectively:

\[
  \begin{array}{rcl}
    \trace(t) & \eqdef & \tracefrag{t} \\
    \trInv[P][\iota] & \eqdef & \knowInv{\iota}{\exists t.\; \trace(t) \ast \pure{P(t)}}
  \end{array}
\]

\rk{resources:mmio_in_heap} \rk{resources:dynamic_mmio}

\newcommand{\MMIOag}{\ownGhost{\gamma_{\X{MMIO}}}{\authfull (\X{MMIO})}}

\section{Toplevel Theorem (\emph{Ã  la} OCPL)}

Let us start with a brief recap of the toplevel ``Robust Safety'' theorem for
OCPL itself (and its key ingredients), then the extension (by Thomas) of OCPL to
include a \I{print} capability, and finally move to the capability machine
setting.

\subsection{OCPL}

The {\sc RobustSafety} theorem of OCPL is as follows:

\begin{mathpar}
  \mprset{vskip=0.3em}
  \inferrule
  {C \in \textit{AdvCtx} \\
    e \; \X{closed} \\
    \hoare{\TRUE}{e}{x\ldotp \lowval x} \\
    (C[e]);(\emptyset, \Sf{OK}) \longrightarrow^* T';(h',g')
  }
  {g' = \Sf{OK}}
\end{mathpar}

For any closed expression $e$, if $e$ has been verified to only return low
values, then running $e$ wrapped in an adversarial context $C$ from an initial
state, then we can observe that every reachable state is good
($g' = \Sf{OK}$ means that no assertion has failed in $e$).

$C \in AdvCtx$ means that $C$ cannot contain assertions (otherwise one could
trivially contradict the theorem by taking
$C[\cdot] = \Sf{assert}\spac \X{false}$), and cannot contain references to raw
memory locations (otherwise one could directly access $e$'s private state,
invalidating the local state encapsulation mechanisms).

\newcommand{\lift}[2]{\lifto #1 \: #2}
\newcommand{\liftP}[1]{\lift{\Psi}{#1}}

$\Sf{lowval}\; x$ intuitively means that $x$ cannot be used to directly
access private (or ``high'') locations. It is formally defined using a logical
relation ``$\liftP{v}$'', which more generally asserts that the value $v$ only
gives direct access to locations that satisfy the predicate $\Psi$.

\[
  \begin{array}{lcl}
    \liftP (\Sf{rec}\; f\; x.\; e) & \eqdef
    & \later \forall v.\; \hoare{\liftP{v}}{e[v/x,\Sf{rec}\;f\;x.\; e/f]}{y.\; \liftP y} \\
    %
    \liftP (v_{1}, v_{2}) & \eqdef & \later (\liftP v_{1}, \liftP v_{2}) \\
    %
    \color{BrickRed} \liftP \ell & \color{BrickRed} \eqdef & \color{BrickRed} \Psi \; \ell \\
    %
    \ldots
  \end{array}
\]

Then, $\lowval x$ is defined as $\lift{\Sf{lowloc}}{x}$, where
$\Sf{lowloc}$ is a predicate characterizing the region of memory containing
``low locations'' (distinct from the other region containing ``high
locations'').

\subsection{OCPL with \I{print}}

\newcommand{\OutV}{\Sf{Out}}

In Thomas' extension of OCPL, a new value $\OutV$ is added, denoting an
``output object capability'', as well as a $\Sf{print}$ primitive, where
$\Sf{print}\; \OutV\; v$ effectively ``prints'' the value $v$, i.e. adds it
to the trace of printed values.

One then wants to be able to encapsulate the use of $\OutV$, for instance by
defining object capabilities that enforce some invariants on the values being
printed. In that setting, $\OutV$ is considered as a ``high'' value:
%
\[
  \begin{array}{lcl}
    \liftP \OutV & \eqdef & \FALSE
  \end{array}
\]

The theorem then becomes:
%
\begin{mathpar}
  \mprset{vskip=0.4em}
  \inferrule
  {C \in \textit{AdvCtx} \\
    e \; \X{closed} \\
    \trInv \vdash \hoare{\TRUE}{e}{x.\; \operatorname{\Sf{lowval}} x} \\
    (C[e]);(\emptyset, \Sf{OK}); \emptyset \longrightarrow^* T';(h',g'); t
  }
  {g' = \Sf{OK} \wedge P(t)}
\end{mathpar}


That is, if $e$ has been verified under the assumption that the predicate $P$
holds as a trace invariant, then executing $e$ in an adversarial context yields
a trace that does satisfy $P$.

$C \in \textit{AdvCtx}$ also has to be extended to forbid $C$ from containing
$\OutV$.

\medskip

To be slightly more general, we could actually allow sharing $\OutV$ in case the
predicate $P$ does not place any constraints on the output, i.e. it is the
$\TRUE$ predicate. Technically, we could hence have the following alternative
definition for $\Sf{lift}$ (although admittedly, it does look a bit
hard-coded):
%
\[
  \begin{array}{lcl}
    \liftP \OutV & \eqdef & \trInv[\Lam{\_}.\TRUE]
  \end{array}
\]

\subsection{Capability Machine with MMIO}

\subsubsection{Logical relation}

\newcommand{\VR}{\mathcal{V}}
\newcommand{\ER}{\mathcal{E}}
\newcommand{\RR}{\mathcal{R}}
\newcommand{\notMMIO}{\overline{\MMIO}}

Similarly to $\Sf{lift}$, we can generalize the existing logical relation
to thread a constraint on directly accessible memory locations. One would
parameterize the value, expression and register relations ($\VR$, $\ER$ and $\RR$)
with a predicate $\Psi$ on addresses.

Then, for any permission $p$ that includes either the R or W bit, $\VR$
is extended as follows:

\[
  \VR^{\Psi}(W)(p, g, b, e, a) \eqdef \underbrace{\ldots}_{\text{as before}} \ast \; \pure{\forall a' \in [b,e).\; \Psi(a')}
\]

Then, $\ER^{\Psi}$ and $\RR^{\Psi}$ are simplify defined by threading the extra
$\Psi$ parameter through the existing definition.

Finally, for our relation to characterize ``low values'' that do not give direct
access to MMIO addresses, one would instantiate $\Psi$ with a predicate
$\notMMIO$ that excludes memory mapped addresses:

\[
  \notMMIO(a) \eqdef a \notin \MMIO
\]

Then, $\VR^{\notMMIO}$ is similar to the $\lowval$ predicate of OCPL.
Intuitively, a value in the relation does not directly point to memory-mapped
locations, nor can it gain access to memory-mapped locations indirectly,
similarly to how $\lowval$s cannot grant access to high locations
directly. The relation $\ER^{\notMMIO}$ specifies that, if we fill the registers
with values in $\VR^{\notMMIO}$, then the invariants in a private future world
of our starting world will be satisfied at the end of execution.
%
\rk{toplevel:v_psi}



\subsubsection{Robust safety theorem}

A first attempt at adapting the OCPL robust safety theorem to the capability
machine setting might look something like the following
{\color{BrickRed}\textbf{(incomplete!)}} statement.

\newcommand{\Wpub}{\sqsupseteq^{\X{pub}}}
\newcommand{\Wpriv}{\sqsupseteq^{\X{priv}}}
\begin{mathpar}
  \mprset{vskip=0.5em}
  \inferrule
  { \forall a_{i} \in A_{\X{entry}} \ldotp\,
      \trInv\!
         \vdash
         \forall W \ldotp\;\ER^{\notMMIO} (W) (\X{RX}, g, b, e, a_i)
       \\
     \\
    (r[\overline{r_{a_{i}} := (\X{E}, g, b, e, a_i)}], m, \emptyset) \longrightarrow^*
    (r', m', t)
  }
  {P(t)}
\end{mathpar}

The code that is verified (similar to the expression $e$ in OCPL) is here given
as a set of \emph{entrypoints} (addresses) $A_{\X{entry}}$.
%
The capability $(\X{RX}, g, b, e, a_i)$ then points to the $i$th entry point of
the code we want to gradually verify.
%
\rk{toplevel:single_entrypoint}

The capability $(\X{E}, g, b, e, a_i)$ then represents a closure for this same
piece of code. Adversarial code should only get access to the closure (as an
enter capability), in order to prevent it from executing or reading arbitrary
lines of code within the trusted module.

Notice that we also need to provide a world to instantiate the expression
relation, here, we universally quantify over it...
%
\rk{toplevel:ocpl_explicit_worlds}

\bigskip

The theorem above is \emph{incomplete}. In particular, it is not provable as
is, because it includes no notion of adversarial context (similar to OCPL's
\textit{AdvCtx}), and therefore imposes no restriction on the adversarial code
(i.e., the contents of the $r$ and $m$ other than our verified code).
%
As such, the statement can be trivially falsified by taking an attacker with
direct read or write access to any location in \MMIO, or with direct access to
the trusted code's internal state.

We now try to develop a theorem statement that correctly constrains the adversary.

A first thing that is lacking is a way to constrain the memory and the registers of the adversary once it gains control.
We have to add a condition (on the state of the reachable memory and registers) to the tentative statement of our robust safety theorem, ensuring that the adversary code cannot gain access to any non-$\X{E}$ capabilities pointing into the driver code or any capabilities pointing into $\MMIO$ directly.
A possible way of syntactically expressing this condition (and in the process overestimating it), is to define the predicate $\nonCap$ below.
More specifically, we can implement the syntactic check as requiring registers and memory (except perhaps driver memory) to only contain non-capability values:

\def \MathparLineskip {\lineskiplimit=0.7em\lineskip=0.7em}
\begin{mathpar}
  \nonCap{\X{inl}\; z} \eqdef \TRUE \and
  \nonCap{\X{inr}\; (p,g,b,e,a)} \eqdef \FALSE \and
  \nonCap{\V{reg}} \eqdef \forall r \in \dom(\V{reg}).\; \nonCap{\V{reg}(r)} \and
  \nonCap{\V{mem}} \eqdef \forall l \in \dom(\V{mem}).\; \nonCap{\V{mem}(l)}
\end{mathpar}
\rk{toplevel:less_restricted_syntactic_check_adverary}

This condition can also easily be specified in terms of the value relation $\VR^{\notMMIO}$, by requiring the registers and part of the PC register to be valid, as will be demonstrated below. This more semantic specification is easily implied by the syntactic one above, and is additionally the one we will need to apply the ftlr to the adversary code, hence proving that it executes securely.

Another change we add is that rather than having execution start off with the adversary, we model the entire boot process of a capability machine, and allow so-called \emph{boot code} to run before the adversary does.
Because of this set-up, rather than having a theorem that assumes unknown adversary code to start executing immediately, we provide an end-to-end theorem that assumes the existence of this piece of boot code, that gets to run first when the capability machine starts up, and makes sure the necessary conditions for the ftlr indeed hold before passing control to the adversary.
The boot code is part of the trusted code base, and must satisfy a given specification, as a precondition of the toplevel theorem. We call this bootcode specification BootSpec and will demonstrate it below.
The particular implementation of the boot code depends on the model of the initial state of the machine.
If the memory can contain any capability at startup, then the boot code has to erase the memory before passing control. If we assume that the initial memory cannot contain any capabilities whatsoever, then the boot code does not need to do any cleanup.

In this setting, we can subdivide the memory $m$ into 3 relevant subsections;
$m = m_{\MMIO} \uplus m_{\X{driver}} \uplus m_{\X{adv}}$ %\uplus m_{\X{frame}}
with the following meaning:
\begin{itemize}
\item $m_{\MMIO}$ contains the memory-mapped locations
\item $m_{\X{driver}}$ contains the driver code from address $b$ to $e$
\item  $m_{\X{adv}}$ contains the adversary's code and data (this will also
  include the boot code in the general setting, since it does not contain any
  inherently dangerous capabilities itself). For simplicity, we will assume a contiguous region for the adversary, from $b_{\X{adv}}$ to $e_{\X{adv}}$.
\end{itemize}

Given this definition, we could now formalize the initialization constraints on
registers $r$ and memory $m$, given the region \MMIO and
the driver's address space $[b,e)$ on paper as follows:

\begin{mathpar}
  \mprset{vskip=0.4em}
  \inferrule
  { m = m_{\MMIO} \uplus m_{\X{driver}} \uplus m_{\X{adv}}\\
    \dom( m_{\MMIO} ) = \MMIO \\
    \dom( m_{\X{driver}} ) = [b,e)\\
    \dom( m_{\X{adv}} ) = [b_{\X{adv}},e_{\X{adv}})\\
    \nonCap{\V{r}}\\
    \nonCap{\V{m_{\X{adv}}}} \\
    r[\X{PC}] = (\X{RWX}, \X{G},b_{\X{adv}},e_{\X{adv}},b_{\X{adv}})\\
  }
  {\initOK{[b,e)}}
\end{mathpar}

However, this predicate is not defined in terms of Iris resources, i.e. we cannot use it in our Coq development yet. We will redefine it below, in the process making it more semantic and hence general. The above predicate, however, demonstrates the state we would like our capability machine to be in when the adverary starts executing. Additionally, we will need to state that any registers pointing to the driver are secure; this is still lacking from the formalization.

\newcommand{\notMapsToR}[2]{\rightarrow^{\overline{#1}}\!\!(#2)}
\newcommand{\Winit}{\X{W_{init}}}
\newcommand{\Wemp}{\emptyset}

The general semantic precondition on adversary execution would then contain the following elements:
\begin{itemize}
\item All registers except \X{PC} are in the value relation with respect to
  a world $W$, meant to contain a single standard region for
  all of the adversary's memory.
  The \X{PC} register satisfies both the read- and write conditions (note the
  parallel with the fundamental theorem) with respect to this same world.
  If we ever want to allow more than just enter capabilities to point to the driver's memory, we have to make sure that some region governing the driver is part of the world $W$. It is not entirely clear yet how to do this in our current development.
\item We have possession of the predicates $\I{region}$ and
  $\I{sts\_full\_world}$ for the world we picked in the previous bullet. we will
  need these to apply the fundamental theorem.
\end{itemize}


We can now take a closer look at the scenario where a piece of boot code is used to set the memory up correctly,
obviating the need for any other assumptions than that the boot code behaves
according to some spec.

Let $r_0$ and $m_0$ be the respective initial state of registers and memory
immediately after booting. We assume that the following two properties hold,
where $l_\X{boot}$ is some memory location (initially loaded in PC):
%
\begin{mathpar}
  \dom(m_0) = [0,\X{MEM_{MAX}}) \and
  r_0[\X{PC}] = (\X{RWX}, \X{G},0,\X{MEM_{MAX}},l_{\X{boot}})
\end{mathpar}

Depending on the specifics of the operiational semantics, we might have more
information about $m_0$ and $r_0$, that can then be used in the implementation
of the boot code (e.g., $m_0$ might be initialized to only zeroes).

We also assume the capability machine to initially start execution in the boot code  at address $l_{\X{boot}}$.

%
Then, the semantic specification for the boot code that we have to prove is
stated as follows:

\[
  \begin{array}{l}

 \X{bootCont}(P,\Phi,\Winit) \eqdef \forall b_{\X{adv}}\; e_{\X{adv}}\; a_{\X{adv}}\;\overline{w_r}\; (W' \Wpriv \Winit) \ldotp\;  \\[0.2em]
    \begin{array}{l}
      \begin{array}{l}
        (\X{PC} \mapsto_{r} (\X{RWX}, \X{G}, b_{\X{adv}}, e_{\X{adv}}, a_{\X{adv}})
        \ast \VR^{\notMMIO} (W')(\X{RW}, \X{G}, b_{\X{adv}}, e_{\X{adv}}, a_{\X{adv}}) \ast {} \\[.6em]
        \bigast{r \in Reg\setminus \{\X{PC}\}}{(r \mapsto_{r} w_r \ast
        \VR^{\notMMIO} (W')(w_r))} \ast {} \\[1.2em]
        \X{region}(W') \ast  \X{sts\_full\_world}\; \X{sts\_std} \;
        W')\\[0.5em]       \end{array}
    \end{array} \\[2em]
    \quad\wand
    \begin{array}{l}
     \wpre{\I{Seq}\; (\I{Instr}\; \I{Executable})}{\Phi}
    \end{array}\\[1.2em]

  \X{bootSpec}(P,r_0,m_0) \eqdef \forall \Phi \ldotp \\[0.8em]
    \quad
  \begin{array}{l}
    \left\{
    \begin{array}{l}
      \X{PC} \mapsto_{r} (\X{RWX}, \X{G}, 0, \X{MEM_{MAX}}, l_{\X{boot}}) \ast {} \\[0.5em]
      \bigast{r \in \X{Reg} \setminus \X{PC}}{r \mapsto_{r} r_{0}[r]}
      \ast \bigast{m \in \X{Mem} \setminus \MMIO}{m \mapsto_{a} m_{0}[m]} \ast\\[.5em]
      \X{region}(\emptyset) \ast  \X{sts\_full\_world}\; \X{sts\_std} \; \emptyset\ast \; \trInv \; \ast \\[.5em]
      \later \X{bootCont}(P,\Phi,\emptyset)
    \end{array}
    \right\}
    \\[2.5em]
    \quad \I{Seq}\; (\I{Instr}\; \I{Executable})
    \\[0.2em]
    \left\{ \Phi \right\}
  \end{array}\\[4em]

  \end{array}
\]

To prove that any closures the boot code might create in the above actually constitute valid register values, we would need to prove the following, with $A_{\X{entry}}$ the set of entry points to the driver:
\[
 \forall a_{i} \in A_{\X{entry}} \ldotp\,           \forall W \Wpriv \Winit \ldotp\;\ER^{\notMMIO} (W) (\X{RX}, g, b, e, a_i)
\]

To actually be able to construct this proof, we will need the following 2 elements (they both need to be persistent, so that we can use them within the execution condition):

\[
    \trInv \ast
    \driverC(b,e,\overline{\V{w}_l})
\]
Here we defined $\driverC$ to be a description of the exact driver code, still in terms of points-to chunks. We can write this invariant as
      $\driverC(b,e,\overline{\V{w}_l}) = \knowInv{\iota}{\bigast{l \in [b,e)}{l \mapsto_{a} \mathit{\V{w}_l}}}$, with $\V{w}_l$
      some hard-coded driver word (an instruction or a capability) at location $l$.

To prove the \X{PC} register valid, we will often be able to use the fact that the memory left by the boot code only contains integers $z$, i.e.\ that the $\mathrm{nonCap}$ predicate holds for memory.

Note that the above specification does not allow for a scenario where we have multiple set-up programs in a row, i.e.\ multiple boot or set-up processes that each need some form of access to \MMIO, that each want to set up their own closures and that we want to verify modularly. The trust model of these set-up procedures goes bottom-up, i.e. any set-up procedure only trusts the set-up procedures that ran before it to ensure that its preconditions are satisfied when it assumes control.
To allow for such a scenario, the execution of the bootcode has to be split up into different phases, where it holds that the postondition (precondition of the continuation) of boot program $i$ implies the precondition of boot program $i+1$. Additionally, the last bootloader has to make sure that the registers it delivers are safe with respect to $\VR^{\notMMIO}$, such that the ftlr (which will only hold for adversaries that have no access to \MMIO whatsoever) can be applied.

In general, each set-up process $i$ will require the following as a precondition to safely execute.
\begin{itemize}
\item Safe register values, with respect to some argument World $W$ (whose regions are standard - this will mostly be used for proving the enter capabilities to e.g\ the driver secure, and I expect this world to be empty at the moment) and a set of \MMIO locations $\br{\MMIO_{i}}$, for which it holds that $\MMIO_i \subseteq \MMIO$. This allows the process to perform some $\MMIO$, but only to locations in $\MMIO \setminus \MMIO_i$. We could allow non-safe values in registers as well, but for simplicity's sake, we model the PC to access any non-safe values instead. Since the PC can point to unsafe values, we can currently set $\MMIO_i = \MMIO$ for simplicity's sake. In the more general case, more strict functional requirements $\br{\X{REG}_i^{\X{pre}}}$ on non-valid registers could be made.
\item Its code and data stored somewhere accessible in memory (using regular points-to chunks), described by a set of constraints (containing points-to chunks) $\br{\X{MEM}_i^{\X{pre}}}$. Generally, also point-to chunks for memory that will be used in the future. This is the region $\br{R_{\X{adv},i}}$ Note that it is possible to write drivers that use relative addressing in their spec to not make their precondition unnecessarily strict.
\item The $PC$ register points to (a subset of)  $R_{\X{adv},i}$.
  The exact constraints are enforced in $\X{MEM}_i^{\X{pre}}$.
  % currently represented as a contiguous range $\br{[b_{\X{adv},i},e_{\X{adv},i}[}$,
  so that it is actually possible for our process to access this non-standard memory.
  Optionally, part of the memory the $PC$ points to can be in $W$, but then the precondition needs to contain a proof that this part of the $PC$ is $RW$-valid, i.e. $\in \VR(\X{RW},\ldots)$, so that we can actually obtain the necessary points-to chunks from the region predicate.

\item An invariant $\trInv$ on the trace, so that the process can perform IO itself or create more closures to do so.
\end{itemize}

Each set-up process will deliver the following postcondition (precondition of the continuation) to the next set-up process or to adversary code, starting from the precondition: (this also means that the proof of the next process has to go through, given this postcondition, i.e. it has to be sufficiently specific)
\begin{itemize}
\item Safe register values in any ($\forall$) private future world of $W$, with respect to the relation $\VR^{\notMMIO_{i+1}}$, where it has to hold that $\MMIO_{i} \subseteq \MMIO_{i+1}$ (which is currently trivially satisfied, since $\MMIO_i = \MMIO$) i.e. the permissions to perform IO are monotonely decreasing as set-up progresses. This constitutes no problem for instances of $\ER$ proven in earlier set-up programs, since the expression relation respects the following contravariant monotonicity property (since the value relation appears in the precondition of the observation relation): $S_1 \subseteq S_2 \Rightarrow \ER^{\overline{S_2}} \subseteq \ER^{\overline{S_1}}$. Note that for $\RR$ and $\VR$ the implication is covariant, so registers containing non-enter capabilities cannot trivially be ported to the next phase of boot.
\item Some description of the layout of memory and concrete register values $\br{\X{REG}_i^{\X{post}}}$ and  $\br{\X{MEM}_i^{\X{post}}}$, that should be sufficiently detailed to be able to prove the precondition of the next set-up program.
\item The trace invariant $\trInv$ (so that the next process can perform its own $\MMIO$). In the future, we can allow strengthening of $P$ throughout set-up by creating a monotone resource algebra for predicates, similarly to what we did for OCPL.
We would then get $\knowInv{\iota}{\exists\; t, P \ldotp \tracefrag{t} \ast \ownGhost{\gamma_{\X{P}}}{\authfull{P}}\ast \pure{P(t)}}$ and could pass around a predicate $\ownGhost{\gamma_{\X{P}}}{\authfrag{P}}$ that we could strengthen before passing it to the next phase of set-up (we would need a notion of \emph{exact} and \emph{at least}, cfr.\ monotonic references).
\end{itemize}

In the case of the last set-up process $n$, we will also need the following, to be able to prove the semantic bootspec's postondition and in the end apply the ftlr, thereby proving the rest of execution safe:
\begin{itemize}
\item We need that $\MMIO_n = \MMIO$, such that we can apply the ftlr (otherwise some valid registers might grant the adverary access to \MMIO memory, and we cannot consider it an adversarial context in the robust safety sense)
\item For similar reasons, the $PC$ should now point to valid memory only, i.e. the condition $\VR^{\notMMIO} (W)(\X{RW}, \X{G}, b_{\X{adv}}, e_{\X{adv}}, a_{\X{adv}})$ should hold.
\item The trace invariant $\trInv$ is no longer required, since the untrusted adversary code will not be able to perform \MMIO anyway. Leaving it there is not a technical problem either, however, given that the registers and memory will be valid with respect to $\VR^{\notMMIO}$.
\end{itemize}

Using the notation we introduced, we must prove the following for each set-up program (TODO: write an attempt at a more modular spec here):

\[
\begin{array}{l}
    \X{bootCont}_i(P,  b_{adv}, e_{adv}, a_{adv},W, \Phi) \eqdef  \\[0.2em]
    \begin{array}{l}
      \forall  b'_{adv}, e'_{adv}, a'_{adv},W' \Wpriv W \ldotp\\
       \quad\begin{array}{l}
       (\X{PC} \mapsto_{r} (\X{RWX}, \X{G}, b'_{adv}, e'_{adv}, a'_{adv}) \ast \br{\X{MEM}_i^{\X{post}}}(b'_{adv}, e'_{adv}, a'_{adv},W', b_{adv}, e_{adv}, a_{adv},W) \\[0.7em]
        \bigast{r \in Reg\setminus \{\X{PC}\}}{(r \mapsto_{r} w_r \ast \VR^{\notMMIO} (W')(w_r))} \ast {} \\[1.2em]
              \X{region}(W') \ast  \X{sts\_full\_world}\; \X{sts\_std} \; W'
      \ast \; \trInv  )
      \end{array}
    \end{array} \\[4em]
    \qquad\wand
    \begin{array}{l}
     \wpre{\I{Seq}\; (\I{Instr}\; \I{Executable})}{\Phi}
    \end{array}\\[1.2em]

  \X{bootSpec}_i(P) \eqdef \\[0.8em]
    \quad
  \begin{array}{l}
    \forall  b_{adv}, e_{adv}, a_{adv},W,\Phi \ldotp\\
    \left\{
    \begin{array}{l}
      \X{PC} \mapsto_{r} (\X{RWX}, \X{G}, b_{adv}, e_{adv}, a_{adv}) \ast \br{\X{MEM}_i^{\X{pre}}}(b_{adv}, e_{adv}, a_{adv},W) \\[0.7em]
      \bigast{r \in Reg\setminus \{\X{PC}\}}{(r \mapsto_{r} w_r \ast \VR^{\notMMIO} (W)(w_r))} \ast {} \\[1.2em]
      \X{region}(W) \ast  \X{sts\_full\_world}\; \X{sts\_std} \; W
      \ast \; \trInv \; \ast \\[.8em]
      \later \X{bootCont}_i(P,  b_{adv}, e_{adv}, a_{adv},W, \Phi)
    \end{array}
    \right\}
    \\[2.5em]
    \quad \I{Seq}\; (\I{Instr}\; \I{Executable})
    \\[0.2em]
    \left\{ \Phi \right\}
  \end{array}\\[4em]

\end{array}
\]

The overall $\X{bootSpec}$ is now proved by proving the individual $\X{bootSpec}_i$, and proving that they link together, i.e. $\br{\X{MEM}_{i+1}^{\X{pre}}}$ is implied by $\br{\X{MEM}_i^{\X{post}}} $, that the initial precondition of $\X{bootSpec}$ implies $\br{\X{MEM}_{0}^{\X{pre}}}$ and that the postcondition of $\X{bootSpec}$ is implied by $\br{\X{MEM}_n^{\X{post}}} $.

\begin{remark}
  We will have to allocate the above predicates\\ $\X{region}(\Winit) \ast
  \X{sts\_full\_world}\; \X{sts\_std} \; \Winit$ from our Coq development under
  a different ghost name $\gamma$ than we usually do.
  I do not know how exactly that would work on a technical level, but it should somehow. We should probably have $\X{region}(\emptyset) \ast
  \X{sts\_full\_world}\; \X{sts\_std} \; \emptyset$ in the precondition of the hoare triple, and then externally have a universal quantification over the concrete $\I{traceG}$ typeclass used, similar to how OCPL does this.
\end{remark}

\begin{remark}
As Frank mentioned, if we do not enforce any validity constraints on the part of the adversary's memory that is not reachable
from the valid registers themselves, the driver cannot read from this memory in
a useful way during execution (since the memory might contain any value
whatsoever, \'and we cannot obtain a points-to chunk to it).
There is currently no concrete use case for this scenario yet, but it is good to be aware of.
In the general case, we would have to make sure that the parts of the adversary
code that are not pointed to by registers but are needed by the driver for some
reason are present in the world (otherwise, we have no way to obtain the
points-to chunk either), or present in an invariant.
\end{remark}

Intuitively, establishing this specification ensures that, after running the
boot code, we arrive in a state that satisfies $\initOKo$.


The resulting boot-code formulation of the robust safety theorem is now


\begin{mathpar}
  \mprset{vskip=0.5em}
  \inferrule
  { \X{bootSpec}^{\X{sem}}(P,r_0,m_0) \\
  (r_0, m_0, \emptyset) \longrightarrow^* (r, m, t)\\
  }
  {P(t)}
\end{mathpar}

Note that we will need a slightly more general adequacy theorem than is suggested by the above robust safety theorem, where the initial trace is
allowed to not be empty, but rather just satisfy $P(t)$, but that should not
cause any problems.

Note as well that if the boot-code performs I/O, then it is required to preserve
the invariant $P$ on the trace. If needed, one could come up with a more general
theorem statement, where the boot code is allowed to perform arbitrary I/O, and
where $P$ is thus only true of the suffix of the trace for events that occur
\emph{after} the boot code has run.

Lastly, note how the trace invariant that appears in the boot specification is not an atomic invariant, even though atomic invariants might be involved in the verification of the driver if it has state (see e.g.\ the counter example below). We are obliged to have a regular invariant for the predicate over the trace, since otherwise adequacy breaks; even for infinite executions, we have to be able to show that any output values satisfy $P$ at \emph{any} point during execution.

\begin{remark}
 Dominique made the remark that we might want to allow capabilities pointing
 into the driver code that are not enter capabilities, but can just generally be
 proven safe wrt.\ the driver code. This scenario (which we currently do not
 support out of simplicity considerations) would force us to add the driver code
 as a static region to the world. While this would work on paper, it does not in the
 current Coq formalization, since all regions that standard regions point to are
 forced to be standard as well (through the conditions in the different cases of
 the $\I{interp1}$ predicate). Essentially, this behavior is disallowed because
 the Coq development merged the notion of read- and write condition, and there
 is hence no room to define a static region which defines a stricter reading
 policy, but hence disallowes writing. More generally, it is currently
 impossible to plug non-standard regions into the world, and allow standard
 regions to depend on them in any way whatsoever. This was not a problem up
 until now, since our examples never required this sort of dependency.
\end{remark}

\subsubsection{Concrete boot and driver code}
\label{subsec:driverimpl}
Now we have a closer look at the concrete example we would like to verify,
including what its boot code looks like. Our goal is to prove that this concrete
example satisfies \X{bootSpec} and hence the above robust safety theorem.

The code for for the driver scenario we want to gradually verify can
be found in \T{driver\_code.v}. This example file contains more details on the
scenario in the comments. From a more high-level perspective, it contains a
trusted part, consisting of a single MMIO location, boot code to properly set up
the capability machine at start-up, and the code for the driver itself. On the
other hand, the example also contains an untrusted part, consisting of a known,
but untrusted code section and sandbox section (which we do not make assumptions
over).
The first address of the adversary code section is what the trusted part jumps
to once it has finished setting up.

The boot code is where execution starts off when the capability machine is
powered on.
It contains an omnipotent RWX capability (i.e. ranging over all of memory and
providing full permissions over it) starts off execution.
(\textbf{Design Alternative:} in the long run, it might be worthwhile to provide
the boot code with a RWLX capability. Since RWX cannot be upgraded to RWLX, it
is impossible in the current setting to develop a secure stack calling
convention \'a la Lau, where the stack capability has to be local-WL and (in this
case) the driver code has to ensure that there is no other WL than the stack.
However, having a global stack capability is currently not an issue, since the interface to our driver is first order, i.e. it will
never create another adversary stack frame on top of itself (currently, it does
not even use the stack in the first place!), and since we are working in a
single-threaded setting (not very relevant, but I think the multi-threaded
setting is an interesting thought experiment). I avoided unnecessary
complications and hence kept the omnipotent capability as RWX. If the omnipotent
capability were to become RWLX in the future, we would have to be careful using
a stack, since if we want our secure calling convention with a higher order
interface to our driver API, there cannot be any adversary-accessible global
write-local memory, i.e. the reduced omnipotent capability cannot be allowed to be global if we pass it to the adversary. We would thus have to pass a stack capability that we explicitly make local, and a global RWX capability for the rest of memory)

The boot code has the following responsibilities:
\begin{itemize}
  \item Generate the necessary closures (i.e. Enter capabilities) for the
    driver's read and write methods, so that the adversary can use safely use
    them to perform I/O, and any properties that the driver wants to uphold on
    the input-output stream can actually be enforced.
%
  \item Wipe all of the adversary's sandbox section, to make sure no remaining
  capabilities can be found there.
  %
    (\textbf{Design Alternative:} maybe we should try to find out how CHERI
    handles this; is it possible that any lingering capabilities are left in RAM
    on machine start-up? In any case, we are already being slightly unrealistic
    by assuming the adversary code section is just \emph{there}. We have the
    option to not do any erasure, and just make the assumption that adversary
    memory contains no capabilities pointing into MMIO or pointing into the
    driver.).
  %
    It does not, however, wipe the untrusted, hard-coded adversary routine that
    reads $N$ lines of code from a single (and the only) MMIO location in
    memory.
%
  \item Reduce the omnipotent capability to provide RWX access to all of the
    adversary's code, makes it point to the first element of the adversary's
    code section and jumps to it, in order to hand control to the adversary.
    Before the jump, it clears all registers except for the 2 containing the
    read and write driver closures, in order to make sure that no extra
    permissions leak to the adversary.
\end{itemize}

\section{Potential driver clients/properties}
The concrete driver that we described in Section~\ref{subsec:driverimpl} does
not yet enforce any useful safety properties on the traces that it outputs. This
section describes a couple such properties that we might want to enforce,
modifications to the driver that they require and example clients that make use
of our modified driver.

\subsection{Stateless properties}

\paragraph{Printing values $\le 1000$}

To only print values $\le 1000$, we need to wrap the driver's read method in a
function that checks this condition, before passing control to the actual read
method.
On an abstract level, given a function $f$, we would have the following wrapper:
\[
  \wrap{\le 1000} f \eqdef \lambda x\ldotp \X{assert}(x \le 1000); f\; x
\]
, and the closure we share with the environment is hence $\wrap{\le
  1000}(\X{read})$ instead of just $\X{read}$.

A trivial misbehaving client could look as follows:
(TODO: ask Dominique for Lau's code on environments)
\begin{lstlisting}
  move r1 1001
  jmp r2
\end{lstlisting}
It simply loads an argument to write and jumps to the write routine.

A well-behaved client might look as follows:
\begin{lstlisting}
  move r1 0
  jmp r2
\end{lstlisting}

\paragraph{Modelling channel-specific safety properties}
Here, we could encode different channels into our integers (in the spirit of
what Frank mentioned), and enforce different safety properties on the different
channels (by ensuring that we can split $P$).
On a conceptual level, this does not require any changes whatsoever.

\subsection{Stateful properties}

\paragraph{Performing $\le 1000$ I/O operations}

To ensure that no more than 1000 values will be read or sent, the driver needs to
keep some internal state, e.g.\ a single integer value $n$ (at location $l_n$) representing the number of times it has been called.

To accommodate this local state, the initial world will need to contain one
extra region for location $l_n$, that allows any integer values $\ge 0$. Since
this region only has a single state, we can again short-circuit the world and
enforce the constraints we want on $n$ through an invariant directly. We now
discuss the concrete constraint that we are looking for.

We have to tie this integer $n$ to the number of I/O events
present in the trace $t$, otherwise it will prove impossible to verify our
driver. Concretely, the invariant we will verify our driver under changes from

\newcommandx{\NaInvT}[1][1 = \top]{[\X{NaInv}: \X{driver\_nais}.#1]}
\newcommandx{\NaInvI}[2][1 = \iota]{\operatorname{NaInv}^{#1}(#2)}
$\trInv[|t| \le 1000]$ to
$\trInvNp[\exists n \ldotp  \pure{|t| = n \mathrel{\land} n \le 1000} \mathrel{\ast} \ownGhost{\gamma_n}{\authfull n}] \mathrel{\ast} \NaInvI[\iota]{\exists n\ldotp l_n \mapsto n \ast \ownGhost{\gamma_n}{\authfrag n}]}  $, where we defined
%
\[
  \begin{array}{lcl}
    \trInvNp[P_{\X{np}}] & \eqdef & \knowInv{\iota}{\exists t.\; \trace(t) \ast P_{\X{np}}(t)}
   \end{array}
\]
(i.e., the predicate over the trace does not need to be pure any longer).
Concretely, this means that
instead of having a pure predicate $P$ in our robust safety theorem, we should
also allow non-pure predicates $P_{\X{np}}$ that entail $P$, i.e. $\forall t
\ldotp P_{\X{np}}(t) \wand \pure{P(t)} $, since we might have to enforce
other invariants relating to local state over the trace as well.


Note that the following two formalizations do not work, since the trace and counter value are not updated at the same time in the code:
\[
  \begin{array}{lcl}

   \trInvNp[\pure{|t| \le 1000} \ast
  \exists n\ldotp l_n \mapsto n \ast n = |t| ]\\
   \trInvNp[\pure{|t| \le 1000} \ast
    \exists n\ldotp \ownGhost{\gamma}{\authfull{n}} \ast n = |t| ] \ast \knowInv{\iota}{\exists n \ldotp \ownGhost{\gamma}{\authfrag{n}} \ast  l_n \mapsto n}
  \end{array}\\
\]

Using  a non-atomic invariant in the first of these two formalizations would not work either, as it would break the adequacy (as stated earlier); we would not know that the safety property inside $P_{\X{np}}$ was upheld at $any$ point during execution.



\begin{remark}
 I swept this under the rug in the above exposition, but if we allow boot code to run first, we have to
 make sure that the value $n$ indeed corresponds to the number of I/O events
 that have occurred when control is passed to the adversary.
\end{remark}

To make sure we can prove the driver specification, we will have to update the
robust safety theorem slightly to incorporate these changes. Additionally, we probably want to ensure that the non-atomic invariants hold after each boot phase, so we have to add it to the postcondition of each boot spec.

Given a macro instruction to perform loops, a well/mis-behaving client might
look as follows: (TODO: write this out,
and come up with some macro formulation)

\paragraph{Never performing I/O again after some stop token has been read on $\stdin$}
Again, this requires no extra conceptual changes.

\paragraph{Verifying OCP's}
As Arma\"el noted at some point, it should be possible to simulate the
proof-style we see in OCPL by emitting values onto the trace, instead of making
assertions over them. This should give us the same proving power as the OCPL
paper, and allow us to emulate their examples.

\section{Proof sketch}
This section describes the steps involved in proving the robust safety theorem
stated above in some more detail.

\subsection{Adapting WP and the FTLR}
The $\I{Load}$ and $\I{Store}$ cases will require new WP rules, that do not mention
points-to chunks but mention the trace resource instead (and specifically, we
will need rules in the presence of invariants such as $\trInv$ above ), when interactions at
\MMIO locations happen. The general WP spec will need to distinguish between
the MMIO and non-MMIO cases (alternatively, if both cases are too distinct, the
ftlr can make this distinction again).

The relations $\VR,\ER,\RR$ need to be updated in terms of $\notMMIO$ and the FTLR will need to be re-stated in terms of these updated relations. This should again only
require some changes for the $\I{Load}$ and $\I{Store}$ cases, depending on how
we choose to formalize the WP cases above.

\subsection{Proving the driver safe}
Specifically, we need to prove the condition

\[
\forall a_{i} \in A_{\X{entry}} \ldotp\,\left\{
    {\begin{array}{ll}
    \trInv \ast
    \driverC(b,e,\overline{\V{w}_l})\!
         \vdash \\
         \forall W \Wpriv \Winit \ldotp\;\ER^{\notMMIO} (W) (\X{RX}, g, b, e, a_i)
        \end{array}} \right.
\]

mentioned above, for the set $A_{\X{entry}}$ of entry points that the boot code
will actually hand closures out for. This will require reductive reasoning over the concrete code of
the driver, but should not be too hard in the absence of local return pointers
and local driver state.

\subsection{Syntactic boot spec}

Proving the syntactic boot specification given above, again through reasoning on
the concrete boot code that we have written down in our example. This should be
relatively easy, as our boot code erases adversary memory before handing over
control. The proof includes verifying any IO that the boot code might need to
do, using the new WP rules mentioned above.

\subsection{Semantic boot spec}

The semantic boot specification should be derivable from the syntactic one,
combined with the proof of safety of the driver (so that we know that enter
capabilities to the driver are safe). The different elements of the semantic bootSpec continuation can be proven as follows:
\begin{itemize}
\item First off, we can prove \[\exists \overline{\gamma}\ldotp \X{region}(\emptyset) \ast  \X{sts\_full\_world}\;
  \X{sts\_std} \; \emptyset\] for \emph{some} ghost names $\overline{\gamma}$ (we
  left this existential out for simplicity in our spec). This will
  suffice, since all our other proofs are parametric in the concrete ghost names, and we
  can use these specific ghost names to construct an instance of $\X{STSG}$. We
  can then populate the world with a standard, permanent region for the
  adversary's memory, using the chunks $\bigast{m \in [b_{adv}, e_{adv})}{m
    \mapsto_{a} \X{inl}\; \_}$ from the syntactic boot spec. This allows us to
  prove \[\exists \overline{\gamma}\ldotp \X{region}(\Winit) \ast  \X{sts\_full\_world}\;
    \X{sts\_std} \; \Winit\] in the semantic bootspec.
  We could generalize the semantic bootspec slightly, by only requiring $[b_{adv},
  e_{adv})$ to be a subset of adversary memory, but it is not immediately clear
  what we gain from that.
\item $\trInv$ and $\driverC(b,e,\overline{\V{w}_l})$ are trivially proven by
  allocating invariants for $\tracefrag{t} \ast \pure{P(t)}$ and $\bigast{l \in [b, e)}{m \mapsto_{a}\V{w}_l}$ respectively.
\item In proving that
  \[\bigast{r \in Reg\setminus \{\X{PC}\}}{(r \mapsto_{r} w_r \ast
      \VR^{\notMMIO} (\Winit)(w_r))}\]
  holds, we can distinguish two different cases:
  \begin{itemize}
  \item For registers $a_i$ containing closures to the driver, we use the chunks
    $\bigast{a_{i} \in A_{\X{entry}}}{r_{a_{i}} \mapsto_{r} (\X{E},g,b,e,a_i)}$
    from the syntactic bootspec, together with the proof of driver safety. To be
    able to apply the latter, we have to use the $\driverC(b,e,\overline{\V{w}_l})$ and $\trInv$ invariants we allocated earlier.
  \item All other registers will contain integers $\X{inl}\; z$ and will hence
    trivially be in $\VR$. We can just use the chunks $\bigast{r \in
      Reg\setminus \{\X{PC}, A_{\X{entry}}\}}{r \mapsto_{r} \X{inl}\; \_} $ to
    satisfy the proof obligation.
  \end{itemize}
\item The proof of
  \[\X{PC} \mapsto_{r} (\X{RWX}, \X{G}, b_{\X{adv}}, e_{\X{adv}}, b_{\X{adv}})
        \ast \VR^{\notMMIO} (\Winit)({\color{red}\X{RW}}, \X{G}, b_{\X{adv}}, e_{\X{adv}}, a_{\X{adv}}))
  \]
   follows directly from $ \X{PC} \mapsto_{r} (\X{RWX}, \X{G}, b_{adv}, e_{adv},
   b_{adv}) $ in the syntactic boot spec, combined with the shape of $\Winit$
   (i.e. the PC points to a standard, permanent region).
\item The execution condition for the PC with respect to $\Winit$ can be proven
  using the fundamental theorem, since we know from the previous bullet that
  both the read- and write-conditions must be satisfied for the PC register.
  This completes the proof of $\VR^{\notMMIO} (\Winit)({\color{red}\X{RWX}}, \X{G}, b_{\X{adv}}, e_{\X{adv}}, a_{\X{adv}}))
$.
\end{itemize}

\subsection{Proving the robust safety theorem}
Given a proof of the semantic boot spec, it should be fairly simple to
prove that the robust safety theorem holds.

To prove that our entire execution is safe, we will first of all need to prove
that $\X{bootCont_{sem}}(P, g, b, e, A_{\X{entry}},\Phi,\Winit)$ holds. This
should be simple, since part of the precondition is that the PC is in the
execution relation, which is essentially what we need to prove (under sensible
-i.e.\ safe-
memory and registers).

When we know that our entire execution is safe according to the WP predicate, we
can apply adequacy of the weakest precondition (and the fact that we have an
invariant stating that our predicate $P$ must hold), to prove $P(t)$ over
the entire I/O trace $t$.

\appendix

\section{Remarks}

\subsection{Operational Semantics}

\subsubsection{Non-determinism}
\label{rk:opsem:nondet}

With this presentation, the specification of the ``machine'' is very much
decoupled from the model of the devices it might be communicating with. This is
a good thing, I think.

One possible downside is that this makes the operational semantics
non-deterministic, which might or might not be an issue in the future.

There are several ways in which the operational semantics could be made ``more
deterministic''.

One could additionally parameterize the operational semantics by an input-stream
$\stdin$. The updated \textsc{IOLoad} load rule might then look something like
this:
\begin{mathpar}
  \inferrule[IOLoad]
  { r[\X{src}] = (p,g,b,e,a) \\ \X{readAllowed}\; p \\ a \in [b,e) \\ a \in \MMIO
  \\ n = \#\{i \mid t[i] = ( \X{IORead},\_\;,\_) \}  }
  { (r, m, t) \xrightarrow{\I{Load} \; \X{dst} \; \X{src}}
    (r[\X{dst} := \stdin[n]], m, t \app (\X{IORead}, a, \stdin[n])) }
\end{mathpar}

When parameterizing our development with multiple values, we could either write
them out as different Coq \texttt{Parameters} where we need them, or store them
as fields in a \texttt{DriverG} typeclass (the latter is the approach taken in
e.g.\ the code-base of~\cite{sammler-2020}).

One could also take as a parameter a predicate that restricts the set of traces
that are allowed (that is what~\cite{sammler-2020} do).

We could also express more precisely the devices' model, and equip each device
with some internal state, the ability to react on reads or writes, or to perform
an internal step. Then, the operational semantics would either step the usual
way, or whenever a device steps.

I believe this would be somewhat similar to the semantics of I/O system calls
through a foreign function interfaces as formalized in
CakeML~\cite{cakeml-vstte17io}, and also in Perennial~\cite{perennial-lang}.


\subsubsection{PC in MMIO}
\label{rk:opsem:pc_in_mmio}

Additionally, we have the option of disallowing an execution with a \X{PC}
register pointing to a $\MMIO$ location in the semantics.
%
First off, consider that this is an edge case; since we always have points-to
chunks describing the layout of code in memory (and a points-to chunk for
location $l$ doubles as a proof that $l \not\in \MMIO$), it is trivial to prove
that this case would not occur in any of our current examples.
%
If we make no changes to the current code base, this behavior would be allowed,
and the following would happen in both cases described above:
%
\begin{enumerate}
  \item An unconstrained value is read from the location. Any instruction could
    be executed.
%
  \item The predicate $\I{MemLocate}$ in $\I{lang.v}$ will make sure that the
    default value (e.g. $0$) is read and decoded into an instruction when we try
    to execute an \MMIO location. This would not cause a conflict with the
    current WP rules, since a points-to chunk is required in the precondition,
    ensuring that this case does not occur.
    %
    Another alternative is to read the encoding of a $\X{NOP}$ instruction,
    instead of just the value $0$.
\end{enumerate}
%
If we were to simply disallow execution when the PC points into \MMIO, we would
make the semantics of all instructions slightly more complicated, but in a
uniform way.
%
We could simply add $a \not\in \MMIO$ to the predicate $\I{isCorrectPC}$ (or add
it as an additional predicate), which is used to define failing execution. It
would again not be a drastic change, since a points-to for the address $a$ the
PC points to is required by the WP rules regardless, from which we can prove
that $a \not\in \MMIO$.

\subsection{Resources}

\subsubsection{MMIO overlapping with $m$}
\label{rk:resources:mmio_in_m}

For the case where the \MMIO locations are still part of the heap $m$, this
would look as follows:
\[
  \X{state\_interp} \; (r,m,t) :=
    \X{gen\_heap\_ctx}\; r \ast
    \X{gen\_heap\_ctx}\; (m \setminus \MMIO) \ast
    {\color{BrickRed}\tracefull{t}}
\]

Sanity check: we never have allocation of new locations $l$ in our capability
machine, but if we did, that would work in both settings by requiring that
$l \not\in \MMIO$ in the operational semantics rule for \textsc{Alloc}.

\subsubsection{Fine-grained trace resources}
\label{rk:resources:fine_grained_trace}

This is very coarse-grained: either one has the full
ownership for performing I/O and reasoning about it, or one cannot know anything
about it.

A first extension could be to allow observing prefixes of the trace (since
events can only be appended to the trace). The observation that the trace
has a given prefix would be duplicable. This again seems to be an application of
monotonicity, that could be realized by having a duplicable AtLeast part as part
of $\tracefrag{t'}$,
similarly to how we currently model Monotone References.

Another extension, that seems very useful for modular reasoning, would be to
allow splitting the trace along separate range of addresses. Concretely, a trace
containing events about the range of MMIO addresses $[a,c)$ could be split into
two traces, granting ownership over events on addresses $[a,b)$ and $[b,c)$
respectively. Note that recombining these two traces would only yield some
unspecified interleaving of the events from the two traces, and not necessarily
yield the original trace, since in our model, we cannot know the exact
interleaving of IO operations issued by different parties.

One application of this second extension could be the verification of an example
involving ``multiplexed'' I/O, where two separate parts of the code are granted
separate ownership over separate MMIO addresses. These two separate pieces of
code would be verified separately; then, in the end, one could prove that one
gets \emph{some} interleaving of all the events emitted by both components.

\subsubsection{MMIO in the heap}
\label{rk:resources:mmio_in_heap}

As an alternative to having the set of MMIO addresses (\MMIO) as a global
parameter, we could make it part of the state in the operational semantics. In
that case, we would need another resource algebra to model the MMIO locations,
i.e. add do the state interpretation we had before:
%
\[
  \X{state\_interp} \; (r,m,t,\MMIO) := \ldots \ast \MMIOag
\]

(where $\authm(\exm(\X{Trace}))$ is the resource algebra).

\subsubsection{Dynamic MMIO}
\label{rk:resources:dynamic_mmio}

In the future, we might be interested in the dynamic allocation of MMIO memory.
The question is what this would mean, though, since the set of available devices
allowing for MMIO access and the concrete buffers they provide will most likely
still be modeled as fixed at runtime.
Rather, this would allow us to take (un)mapped MMIO locations, connected to the different devices, and (un)map them anywhere in main memory.
This would require a different way of modeling MMIO, where we need both a notion
of the total pool of possible MMIO locations, and a description of the currently
mapped locations. We could model this using an authoritative RA.

\subsection{Toplevel theorem}

\subsubsection{$\VR^\Psi$ with arbitrary $\Psi$}
\label{rk:toplevel:v_psi}

As it is defined above, the ``generalized'' value relation
is in fact not very useful for instantiation of $\Psi$ other than $\notMMIO$.
Indeed, even if $\Psi$ \emph{does} allow referring to addresses in the $\MMIO$
region, the value relation does not grant any corresponding resources. The fix
would be to use the generalized trace resources mentioned previously, and grant
ownership for the part of the trace corresponding to the addresses in
$[b,e) \cap \MMIO_{\X{pub}}$ with $\MMIO_{\X{pub}}$ the shareable subset of
addresses in \MMIO.

\subsubsection{Driver with single entrypoint}
\label{rk:toplevel:single_entrypoint}

We could simplify the theorem statement by only considering the case of a
single entrypoint. This is equivalent: a piece of code that wants to expose
two distinct ``methods'' can implement a single toplevel entrypoint that
immediately returns two pointers that can then be used to invoke the two
methods.
%
This would make the toplevel theorem simpler, at the cost of somewhat more
contrieved calling convention between trusted and untrusted code.
Another alternative is to provide an opcode to specify the operation that
needs to be performed.
This is slightly less general, since it does not allow providing read access
only to an adversary.

\subsubsection{OCPL and explicit worlds}
\label{rk:toplevel:ocpl_explicit_worlds}

The universal quantification on worlds was not explicitly present in the OCPL
formalization.
The reason for that is that (I think so at least, do not quote me
on this - Thomas) they
used the built-in Iris worlds within their definition of weakest precondition,
by leveraging the state interpretation, which is universally quantified over in
the definition of weakest precondition.
As we discussed before, if we do away
with local capabilities, it should be possible to fall back onto Iris' notion of
worlds, which would allow us to remove the universal quantification in the
above definition too because it would be implicitly present in the WP inside $\ER$.

It would be interesting to have a discussion about how to do away with the
worlds if we remove local capabilities, regardless of whether we will in the
end, since that might shed some light on why the worlds look the way they do
right now.

\subsubsection{Less restricted but still syntactic check for the adversary memory}
\label{rk:toplevel:less_restricted_syntactic_check_adverary}

If useful, the syntactic check can be relaxed to allow any capabilities that
do not point into the MMIO region or the driver's memory. One would define the
predicate $\notMapsToR{R}{w}$, that takes a word, memory region or register
file and checks if it points into the forbidden region $R$ as follows:

\[
  \begin{array}{lcl}
    \notMapsToR{R}{\X{inl}\spac z} & \eqdef
    & \TRUE \\
    %
    \notMapsToR{R}{\X{inr}\spac (p,g,b,e,a)} & \eqdef & R \cap [b,e)\; =
                                                 \emptyset  \\
    %
    \notMapsToR{R}{\V{reg}} & \eqdef & \forall r \in \dom(\V{reg}) \ldotp\spac \notMapsToR{R}{\V{reg}(r)} \\
    %
    \notMapsToR{R}{\V{mem}} & \eqdef & \forall l \in \dom(\V{mem}) \ldotp\spac   \notMapsToR{R}{\V{mem}(l)}
  \end{array}
\]

Then, one would use $\notMapsToR{\MMIO \cup [b,e)}$ in place of $\nonCap{}$.

%% Biblio

\bibliographystyle{alpha}
\bibliography{biblio}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
